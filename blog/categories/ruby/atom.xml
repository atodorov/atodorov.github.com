<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>atodorov.org</title><link href="http://atodorov.org/" rel="alternate"></link><link href="http://atodorov.org/blog/categories/ruby/atom.xml" rel="self"></link><id>http://atodorov.org/</id><updated>2016-02-23T13:08:00+02:00</updated><entry><title>Ruby &amp; Time-based Testing</title><link href="http://atodorov.org/blog/2016/02/23/ruby-time-based-testing/" rel="alternate"></link><updated>2016-02-23T13:08:00+02:00</updated><author><name>Alexander Todorov</name></author><id>tag:atodorov.org,2016-02-23:blog/2016/02/23/ruby-time-based-testing/</id><summary type="html">&lt;p&gt;Publishing this mostly for self reference.
Here are two blog posts on the topic of testing time
dependent code in Ruby applications:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://metaskills.net/2012/08/07/synchronized-times-in-ruby-and-javascript-acceptance-tests-using-capybara-timecop-and-sinon-js/"&gt;Synchronized Times In Ruby &amp;amp; JavaScript Acceptance Tests Using Capybara, Timecop &amp;amp; Sinon.JS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.pivotal.io/labs/labs/goodbye-timecop-hello-timehelpers"&gt;Move Over Timecopâ€¦Hello ActiveSupport::Testing::TimeHelpers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I haven't seen a module similar to timecop in Python, but frankly I've never needed one either.&lt;/p&gt;</summary><category term="fedora.planet"></category><category term="Ruby"></category><category term="QA"></category></entry><entry><title>Interesting Ruby Resources</title><link href="http://atodorov.org/blog/2015/12/23/interesting-ruby-resources/" rel="alternate"></link><updated>2015-12-23T12:48:00+02:00</updated><author><name>Alexander Todorov</name></author><id>tag:atodorov.org,2015-12-23:blog/2015/12/23/interesting-ruby-resources/</id><summary type="html">&lt;p&gt;During my quest for
&lt;a href="http://atodorov.org/blog/2015/12/23/speeding-up-rspec-and-postgresql-tests/"&gt;faster RSpec tests&lt;/a&gt;
I've come across several interesting posts about Ruby. Being new to the language
they've helped me understand a bit more about the internals. Posting them here
so they don't get lost.&lt;/p&gt;
&lt;h2&gt;Garbage Collection&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://signalvnoise.com/posts/2742-the-road-to-faster-tests"&gt;The road to faster tests&lt;/a&gt;
- a story about tests and garbage collection.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://labs.clio.com/tuning-ruby-garbage-collection-for-rspec/"&gt;Tuning Ruby garbage collection for RSpec&lt;/a&gt;
- practical explanation of Ruby's garbage collector and how to adjust its
performance for RSpec&lt;/p&gt;
&lt;p&gt;&lt;a href="http://samsaffron.com/archive/2013/11/22/demystifying-the-ruby-gc"&gt;Demystifying the Ruby GC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Probably the very first posts I found referencing slow RSpec tests. It turned out
this was not the issue but I've nevertheless tried running GC manually. I can clearly
see (using &lt;code&gt;puts GC.count&lt;/code&gt; in after()) GC invoked less frequently, memory usage rising
but the overall execution time wasn't affected. The profiler said 2% speed increase
to be honest.&lt;/p&gt;
&lt;h2&gt;Profiling&lt;/h2&gt;
&lt;p&gt;Not being very clear about the different profiling tools available and how to
interpret their results I've found these articles:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.igvita.com/2009/06/13/profiling-ruby-with-googles-perftools/"&gt;Profiling Ruby With Google's Perftools&lt;/a&gt;
- practical example for using perftools.rb&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/32212970/how-to-read-ruby-profilers-output"&gt;How to read ruby profiler's output&lt;/a&gt; -
also see the &lt;a href="http://ruby-doc.org/stdlib-2.1.0/libdoc/profiler/rdoc/Profiler__.html"&gt;Profiler__ module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/4856500/show-runtime-for-each-rspec-example"&gt;Show runtime for each rspec example&lt;/a&gt;
- using &lt;code&gt;rspec --profile&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Suggestions for Faster Tests&lt;/h2&gt;
&lt;p&gt;Several general best practices for faster tests:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.netguru.co/blog/9-ways-to-speed-up-your-rspec-tests"&gt;9 ways to speed up your RSpec tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://infinum.co/the-capsized-eight/articles/run-faster-ruby-on-rails-tests"&gt;Run faster Ruby on Rails tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.plataformatec.com.br/2011/12/three-tips-to-improve-the-performance-of-your-test-suite/"&gt;Three tips to improve the performance of your test suite&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;RubyGems related&lt;/h2&gt;
&lt;p&gt;I've noticed Bundler loading tons of requirements (nearly 3000 unique modules)
and for some particular specs this wasn't necessary (for example running Rubocop).
I've found the following articles below which sound very reasonable to me:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://anti-pattern.com/use-bundler-setup-instead-of-bundler-require"&gt;Use Bundler.setup Instead of Bundler.require&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://myronmars.to/n/dev-blog/2012/12/5-reasons-to-avoid-bundler-require"&gt;5 Reasons to Avoid Bundler.require&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://2ndscale.com/rtomayko/2009/require-rubygems-antipattern"&gt;Why "require 'rubygems'" Is Wrong&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Weird&lt;/h2&gt;
&lt;p&gt;Finally (or more precisely first of all) I've seen this
&lt;a href="https://www.ruby-forum.com/topic/184516 suggests broken rubygems"&gt;Weird performance issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;During my initial profiling I've seen (and still see) a similar issue.
When calling require it goes through lots of hoops before finally loading
the module. My profiling results show this taking a lot of time but this time
is likely measured with profiling enabled and doesn't represent the real deal.&lt;/p&gt;
&lt;p&gt;On my
&lt;a href="http://atodorov.org/blog/2015/04/26/installing-red-hat-enterprise-linux-7-on-macbook-air-2015/"&gt;MacBook Air with Red Hat Enterprise Linux 7&lt;/a&gt;
this happens when using Ruby 2.2.2 from Software Collections. If using Ruby
installed from source with rbenv the profiling profile is completely different.&lt;/p&gt;
&lt;p&gt;I will be examining this one in more details. I'm interested to know what is
the difference and if that affects performance somehow so stay tuned!&lt;/p&gt;</summary><category term="fedora.planet"></category><category term="Ruby"></category></entry><entry><title>Speeding up RSpec and PostgreSQL tests</title><link href="http://atodorov.org/blog/2015/12/23/speeding-up-rspec-and-postgresql-tests/" rel="alternate"></link><updated>2015-12-23T11:34:00+02:00</updated><author><name>Alexander Todorov</name></author><id>tag:atodorov.org,2015-12-23:blog/2015/12/23/speeding-up-rspec-and-postgresql-tests/</id><summary type="html">&lt;p&gt;I've been working with &lt;a class="wikilink" href="http://tradeo.com"&gt;Tradeo&lt;/a&gt; on testing one of their applications. The app
is standard Ruby on Rails application with over 1200 tests written with RSpec.
And they were horribly slow. On my &lt;a class="wikilink" href="http://amzn.to/1RdviyD"&gt;MacBook Air&lt;/a&gt; the entire test suite
took 27 minutes to execute. On the Jenkins slaves it took over an hour.
After a few changes Jenkins now takes 15 minutes to execute the test suite.
Locally it takes around 11 minutes!&lt;/p&gt;
&lt;h2&gt;The Problem&lt;/h2&gt;
&lt;p&gt;I've measured the speed (with Time.now) at which individual examples execute
and it was quickly apparent they were taking a lot of time cleaning the DB. The
offending code in question was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;before&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:all&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;DatabaseCleaner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clean_with&lt;/span&gt; &lt;span class="ss"&gt;:truncation&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is truncating the tables quite often but it turns out this is a very
expensive operation on tables with small number of records. I've measured it
locally around 2.5 seconds. Check out this
&lt;a href="http://stackoverflow.com/questions/11419536/postgresql-truncation-speed/"&gt;SO thread&lt;/a&gt;
which describes pretty much the same symptoms:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Right now, locally (on a Macbook Air) a full test suite takes 28 minutes....
Tailing the logs on our CI server (Ubuntu 10.04 LTS) .... a build takes 84 minutes.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This
&lt;a href="http://stackoverflow.com/questions/11419536/postgresql-truncation-speed/11423886#11423886"&gt;excellent answer&lt;/a&gt;
explains why this is happening:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;(a) The bigger shared_buffers may be why TRUNCATE is slower on the CI server.
    Different fsync configuration or the use of rotational media instead of
    SSDs could also be at fault.

(b) TRUNCATE has a fixed cost, but not necessarily slower than DELETE,
    plus it does more work.
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;The Fix&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;before&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:suite&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;DatabaseCleaner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clean_with&lt;/span&gt; &lt;span class="ss"&gt;:truncation&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;before&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:all&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
  &lt;span class="no"&gt;DatabaseCleaner&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clean_with&lt;/span&gt; &lt;span class="ss"&gt;:deletion&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;before(:suite)&lt;/code&gt; will truncate tables every time we run rspec, which is when we
launch the entire test suite. This is to account for the possible side effects
of DELETE in the future (see the SO thread). Then &lt;code&gt;before(:all)&lt;/code&gt; aka
&lt;code&gt;before(:context)&lt;/code&gt; simply deletes the records which is significantly faster!&lt;/p&gt;
&lt;p&gt;Also updated the CI servers &lt;code&gt;postgresql.conf&lt;/code&gt; to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fsync=off
full_page_writes=off
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The entire build/test process now takes only 15 minutes! Only one test broke
due to PostgreSQL returning records in a different order, but it's the test
case fault not handling this in the first place!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Using fsync=off with rotational media pretty much hides any improvements
introduced by updating the DatabaseCleaner strategy.&lt;/p&gt;
&lt;h2&gt;What's Next&lt;/h2&gt;
&lt;p&gt;There are several other things worth trying:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use UNIX domain sockets instead of TCP/IP (localhost) to connect to PostgreSQL;&lt;/li&gt;
&lt;li&gt;Load the entire
&lt;a href="http://magazine.redhat.com/2007/12/12/tip-from-an-rhce-memory-storage-on-postgresql/"&gt;PostgreSQL partition in memory&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Don't delete anything from the database, except once in &lt;code&gt;before(:suite)&lt;/code&gt;.
If any tests need a particular DB state they have to set this up on their own
instead of relying on a global cleanup process. I expect this to break quite
a few examples.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After the changes and with my crude measurements I have individual examples
taking 0.31 seconds to execute. Interestingly before and after take less than
a second while the example code takes around 0.15 seconds. I have no idea where
the rest 0.15 seconds are spent. My current speculation is probably RSpec.
This is 50% of the execution time and is also worth looking into!&lt;/p&gt;</summary><category term="fedora.planet"></category><category term="Ruby"></category></entry></feed>