<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Django | atodorov.org - you can logoff, but you can never leave]]></title>
  <link href="http://atodorov.org/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://atodorov.org/"/>
  <updated>2014-01-24T22:12:52+02:00</updated>
  <id>http://atodorov.org/</id>
  <author>
    <name><![CDATA[Alexander Todorov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django Template Tag Inheritance How-to]]></title>
    <link href="http://atodorov.org/blog/2013/12/22/django-template-tag-inheritance-howto/"/>
    <updated>2013-12-22T23:02:00+02:00</updated>
    <id>http://atodorov.org/blog/2013/12/22/django-template-tag-inheritance-howto</id>
    <content type="html"><![CDATA[<p>While working on open-sourcing <a href="http://www.dif.io">Difio</a> I needed to remove
all hard-coded URL references from the templates. My solution was to essentially
inherit from the standard <code>{% raw %}{% url %}{% endraw %}</code> template tag. Here is how to do it.</p>

<h2>Background History</h2>

<p>Difio is not hosted on a single server. Parts of the website are static HTML,
hosted on Amazon S3. Other parts are dynamic - hosted on OpenShift. It's also
possible but not required at the moment to host at various PaaS providers for
redundancy and simple load balancing.</p>

<p>As an easy fix I had hard-coded some URLs to link to the static S3 pages and others
go link to my PaaS provider.</p>

<p>I needed a simple solution which can be extended to allow for multiple domain hosting.</p>

<h2>The Solution</h2>

<p>The solution I came up with is to override the standard <code>{% raw %}{% url %}{% endraw %}</code>
tag and use it everywhere in my templates. The new tag will produce absolute URLs containing
the specified protocol plus domain name and view path. For this to work you have to
inherit the standard <code>URLNode</code> class and override the <code>render()</code> method to include the new
values.</p>

<p>You also need to register a tag method to utilize the new class. My approach was to use
the existing <code>url()</code> method to do all background processing and simply casting the result
object to the new class.</p>

<p>All code is available at <a href="https://djangosnippets.org/snippets/3013/">https://djangosnippets.org/snippets/3013/</a>.</p>

<p>To use in your templates simply add</p>

<p>{% codeblock %}{% raw %}
{% load fqdn_url from fqdn_url %}
<a href="{% fqdn_url 'dashboard' %}">Dashboard</a>
{% endraw %}{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Idempotent Django Email Sender with Amazon SQS and Memcache]]></title>
    <link href="http://atodorov.org/blog/2013/12/11/idempotent-django-email-sender-with-amazon-sqs-and-memcache/"/>
    <updated>2013-12-11T23:29:00+02:00</updated>
    <id>http://atodorov.org/blog/2013/12/11/idempotent-django-email-sender-with-amazon-sqs-and-memcache</id>
    <content type="html"><![CDATA[<p>Recently I wrote about my problem with
<a href="/blog/2013/12/06/duplicate-amazon-sqs-messages-cause-multiple-emails/">duplicate Amazon SQS messages causing multiple emails</a>
for <a href="http://www.dif.io">Difio</a>. After considering several options and
feedback from
<a href="https://twitter.com/atodorov_/status/409429840820199424">@Answers4AWS</a>
I wrote a small decorator to fix this.</p>

<p>It uses the cache backend to prevent the task from executing twice
during the specified time frame. The code is available at
<a href="https://djangosnippets.org/snippets/3010/">https://djangosnippets.org/snippets/3010/</a>.</p>

<p>As stated on Twitter you should use Memcache (or ElastiCache) for this.
If using Amazon S3 with my
<a href="https://github.com/atodorov/django-s3-cache">django-s3-cache</a> don't use the
<code>us-east-1</code> region because it is eventually consistent.</p>

<p>The solution is fast and simple on the development side and uses my existing
cache infrastructure so it doesn't cost anything more!</p>

<p>There is still a race condition between marking the message as processed
and the second check but nevertheless this should minimize the possibility of
receiving duplicate emails to an accepted level. Only time will tell though!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django Tips: Using Cache for Stateful HTTP]]></title>
    <link href="http://atodorov.org/blog/2013/06/19/django-tips-using-cache-for-stateful-http/"/>
    <updated>2013-06-19T13:50:00+03:00</updated>
    <id>http://atodorov.org/blog/2013/06/19/django-tips-using-cache-for-stateful-http</id>
    <content type="html"><![CDATA[<p>How do you keep state when working with a stateless protocol like HTTP?
One possible answer is to use a cache back-end.</p>

<p>I'm working on an IVR application demo with Django and Twilio. The caller
will make multiple choices using the phone keyboard. All of this needs to be
put together and sent back to another server for processing. In my views
I've added a simple cache get/set lines to preserve the selection.</p>

<p>Here's how it looks with actual application logic omitted</p>

<p>{% codeblock lang:python %}</p>

<p>def incoming_call(request):</p>

<pre><code>call_sid = request.GET.get('CallSid', '')
caller_id = request.GET.get('From', '')

state = {'from' : caller_id}
cache.set(call_sid, state)

return render(request, 'step2.xml')
</code></pre>

<p>def step2(request):</p>

<pre><code>call_sid = request.GET.get('CallSid', '')
selection = int(request.GET.get('Digits', 0))

state = cache.get(call_sid, {})
state['step2_selection'] = selection
cache.set(call_sid, state)

return render(request, 'final_step.xml')
</code></pre>

<p>def final_step(request):</p>

<pre><code>call_sid = request.GET.get('CallSid', '')
selection = int(request.GET.get('Digits', 1))

state = cache.get(call_sid, {})
state['final_step_selection'] = selection

Backend.process_user_selections(state)

return render(request, 'thank_you.xml')
</code></pre>

<p>{% endcodeblock %}</p>

<p>At each step Django will update the current state associated with this call and return
a <a href="https://www.twilio.com/docs/api/twiml">TwiML</a> XML response. <code>CallSid</code> is a handy unique
identifier provided by Twilio.</p>

<p>I am using the latest <a href="http://github.com/atodorov/django-s3-cache">django-s3-cache</a> version
which properly works with directories. When going to production that will likely switch to
Amazon ElastiCache.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Django built-in template tags and filters in code]]></title>
    <link href="http://atodorov.org/blog/2013/04/06/using-django-built-in-template-tags-and-filters-in-code/"/>
    <updated>2013-04-06T22:26:00+03:00</updated>
    <id>http://atodorov.org/blog/2013/04/06/using-django-built-in-template-tags-and-filters-in-code</id>
    <content type="html"><![CDATA[<p>In case you are wondering how to use Django's
<a href="https://docs.djangoproject.com/en/dev/ref/templates/builtins/">built-in template tags and filters</a>
in your source code, not inside a template here is how:</p>

<p>{% codeblock lang:python %}</p>

<blockquote><blockquote><blockquote><p>from django.template.defaultfilters import *
filesizeformat(1024)
u'1.0 KB'
filesizeformat(1020)
u'1020 bytes'
filesizeformat(102412354)
u'97.7 MB'</p>

<p>{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>All built-ins live in <code>pythonX.Y/site-packages/django/template/defaultfilters.py</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip: Renaming Model Fields in Django]]></title>
    <link href="http://atodorov.org/blog/2013/04/06/tip-renaming-model-fields-in-django/"/>
    <updated>2013-04-06T01:18:00+03:00</updated>
    <id>http://atodorov.org/blog/2013/04/06/tip-renaming-model-fields-in-django</id>
    <content type="html"><![CDATA[<p>Did you ever have to re-purpose a column in your database schema?
Here's a quick and easy way to do this if you happen to be using Django.</p>

<h2>Scenario</h2>

<p>I had an integer field in my model called <code>lines</code> which counted the lines of
code in a particular tar.gz package. I figured the file size is a better indicator
so decided to start using it. I was not planning to use the old field anymore and
I didn't care about the data it was holding. So I decided to re-purpose it
as the <code>size</code> field.</p>

<h2>Possible methods</h2>

<p>Looking around I figured several different ways to do this:</p>

<ol>
<li>Continue using the existing <code>lines</code> field and keep referencing the old name in the code.
This is no-brainer but feels awkward and is a disaster waiting to happen;</li>
<li>Add new <code>size</code> field and remove the old <code>lines</code> field. This involves modification to
the DB schema and requires at least a backup with possible down time. Not something
I will jump at right away;</li>
<li>Add a <code>size</code> property in the model class which will persist to <code>self.lines</code>.
This is a quick way to go but I'm not sure if one can use the property with the
Django QuerySet API (objects.filter(), objects.update(), etc.) I suspect not.
If you don't filter by the property or use it in bulk operations this method is fine though;</li>
<li>Change the field name to <code>size</code> but continue to use the <code>lines</code> DB column;
Mind my wording here :);</li>
<li>Rename the column in the DB schema and then update the model class field.</li>
</ol>


<h2>How I did it</h2>

<p>I decided to go for option 4 above:
change the field name to <code>size</code> but continue to use the <code>lines</code> DB column.</p>

<p>{% codeblock lang:diff %}
diff --git a/models.py b/models.py
index e06d2b2..18cad6f 100644
--- a/models.py
+++ b/models.py
@@ -667,7 +667,7 @@ class Package(models.Model):
-    lines = models.IntegerField(default=None, null=True, blank=True)
+    size  = models.IntegerField(default=None, null=True, blank=True, db_column='lines')
{% endcodeblock %}</p>

<ol>
<li>Removed all references to <code>lines</code> from the code except the model class. This served as clean up as well.</li>
<li>Renamed the model field to <code>size</code> but continued using the <code>lines</code> DB column as shown above.
Django's <em>db_column</em> option makes this possible.</li>
<li>From the Django shell (./manage.py shell) reset <code>size</code> to None (NULL) for all objects;</li>
<li>Finally implement my new code and functionality behind the <code>size</code> field.</li>
</ol>


<p>The entire process happened for under 10 minutes. I will also opt for renaming the DB column at a later time.
This is to sync the naming used in Python code and in MySQL in case I ever need to use raw SQL or anything but Django.</p>

<p>If you were me, how would you do this? Please share in the comments below.</p>
]]></content>
  </entry>
  
</feed>
